from __future__ import annotations
import unittest
import d3i
from d3i.emitters.dotnet_emmiter.ModelEmitter import *
from io import StringIO


class TestEmitterDotnetDefault(unittest.TestCase):

    def setUp(self):
        self.__init_roslyn()

    def test_modelemitter_enum_ok(self):
        engine = d3i.Engine()
        session = d3i.Session()
        session.AddSource(d3i.Source.CreateFromText("""
domain WebShop {
    context CustomerContext {
        enum CustomerType{
            PrivatePerson,
            Company
        }
    }
}
"""))
        root = engine.Build(session)
        emitter = ModelEmmiter()
        result = emitter.Emit(session)
        expected = """
// <auto-generated>
//     This code was generated by d3i.interpreter
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
using System;
using System.Collections.Generic;

namespace WebShop.CustomerContext
{
    enum CustomerType
    {
        PrivatePerson,
        Company,
    }
}
"""
        self.assertTrue(self.__dotnet_code_is_equal(expected, result))

        print(result)

    def __init_roslyn(csharp_code: str):
        from pathlib import Path
        from pythonnet import get_runtime_info, set_runtime
        set_runtime("coreclr")
        import clr
        print(get_runtime_info())

        clr.AddReference(str(Path("./tools/dotnet_dlls/netstandard2.0/Microsoft.CodeAnalysis.dll").resolve()))
        clr.AddReference(str(Path("./tools/dotnet_dlls/netstandard2.0/Microsoft.CodeAnalysis.CSharp.dll").resolve()))

    def __dotnet_code_is_equal(self, expected, result):
        expected = self.__format_with_roslyn(expected)
        result = self.__format_with_roslyn(result)

        return expected == result

    def __format_with_roslyn(self, dotnet_code: str):
        dotnet_code = self.__remove_whitespaces(dotnet_code)
        dotnet_code = self.__remove_empty_lines(dotnet_code)

        syntax_node: SyntaxNode = self.__get_syntax_tree(dotnet_code).GetRoot()
        syntax_node = self.__remove_comments(syntax_node)
        syntax_node = self.__remove_line_pragmas(syntax_node)

        return syntax_node.NormalizeWhitespace().ToFullString().replace("\r", "")

    def __remove_whitespaces(self, dotnet_code: str):
        reader = StringIO(dotnet_code)  # Create an in-memory string reader to read the input code
        writer = StringIO()  # Create an in-memory string writer to collect the processed lines

        while True:
            line = reader.readline()  # Read a single line from the input
            if not line:  # If we reach the end of the input, break the loop
                break

            line = line.rstrip("\n")  # Remove the newline character to work with the line

            if len(line) > 0:
                # Remove leading whitespaces
                while line and line[0].isspace():
                    line = line[1:]

                # Remove trailing whitespaces
                while line and line[-1].isspace():
                    line = line[:-1]

                # Replace double spaces with a single space, and replace tabs with spaces
                before_length = 0
                after_length = 0
                while True:
                    before_length = len(line)
                    line = line.replace("  ", "")  # Remove double spaces
                    line = line.replace("\t", " ")  # Replace tabs with spaces
                    after_length = len(line)

                    if before_length == after_length:  # If no changes occurred, stop the loop
                        break

            writer.write(line + "\n")  # Write the processed line to the writer

        return writer.getvalue()

    def __is_empty_line(self, line: str) -> bool:
        """
        Helper function that determines if a given line is empty (only contains whitespace).
        """
        return line.strip() == ""

    def __remove_empty_lines(self, dotnet_code: str) -> str:
        """
        Removes empty lines from a given text.
        """
        from io import StringIO

        writer = StringIO()  # In-memory string writer to collect the non-empty lines
        reader = StringIO(dotnet_code)  # In-memory string reader to read the input code

        # Read through each line of the input code
        while True:
            line = reader.readline()  # Read a single line
            if not line:  # If we've reached the end of the input, break out of the loop
                break

            if not self.__is_empty_line(line):  # If the line is not empty, write it to the output
                writer.write(line)

        return writer.getvalue()  # Return the final result as a string

    def __get_syntax_tree(self, dotnet_code: str):
        from Microsoft.CodeAnalysis.CSharp import CSharpSyntaxTree
        from Microsoft.CodeAnalysis import SyntaxTree

        return CSharpSyntaxTree.ParseText(dotnet_code)

    def __dotnet_code_is_has_compliable(self, dotnet_code: str):
        try:
            # Translate C# code to syntax tree
            syntax_tree = self.__get_syntax_tree(dotnet_code)
            diagnostics = syntax_tree.GetDiagnostics()

            #  If there are diagnostic errors, the code is not valid
            errors = [error for error in diagnostics if error.Severity == 2]
            return len(errors) == 0
        except Exception as e:
            print(f"Hiba történt: {e}")
            return False

    def __remove_comments(self, syntax_node):
        from Microsoft.CodeAnalysis import SyntaxNodeExtensions
        import clr
        import System

        try:
            trivias = syntax_node.DescendantTrivia()
            csharp_list = list(syntax_node.ChildNodes())[0].Parent
            return SyntaxNodeExtensions.ReplaceTrivia(
                syntax_node,
                trivias,
                lambda st1, st2, st3: self.__replace_comments(self, st1, st2, st3)
            )
        except Exception as e:
            print(f"Hiba történt: {e}")
            return False

    def __remove_line_pragmas(self, syntax_node):
        return syntax_node.ReplaceTrivia(
            syntax_node.DescendantTrivia(),
            lambda st1, st2: self.__replace_line_pragmas(self, st1, st2)
        )

    def __replace_comments(st1, st2, st3):
        # Check if the trivia is a comment (single-line or multi-line)
        if st1.IsKind(SyntaxKind.SingleLineCommentTrivia) or st1.IsKind(SyntaxKind.MultiLineCommentTrivia):
            st2 = SyntaxFactory.CarriageReturn  # Replace with CarriageReturn
        else:
            st2 = st1  # Keep the original trivia if it's not a comment
        return st2

    def __replace_line_pragmas(st1, st2, st3):
        # Check if the trivia is a line pragma
        if st1.IsKind(SyntaxKind.LineDirectiveTrivia):
            st2 = SyntaxFactory.CarriageReturn  # Replace with CarriageReturn
        else:
            st2 = st1  # Keep the original trivia if it's not a comment
        return st2


if __name__ == "__main__":
    unittest.main()
